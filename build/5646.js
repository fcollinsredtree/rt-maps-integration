"use strict";(globalThis.webpackChunkredtree_maps_integration=globalThis.webpackChunkredtree_maps_integration||[]).push([[5646],{36852:(e,t,r)=>{r.d(t,{O:()=>i});class i{constructor(){this._outer=new Map}clear(){this._outer.clear()}get empty(){return 0===this._outer.size}get(e,t){return this._outer.get(e)?.get(t)}set(e,t,r){const i=this._outer.get(e);i?i.set(t,r):this._outer.set(e,new Map([[t,r]]))}delete(e,t){const r=this._outer.get(e);r&&(r.delete(t),0===r.size&&this._outer.delete(e))}forEach(e){this._outer.forEach(((t,r)=>e(t,r)))}}},5646:(e,t,r)=>{r.r(t),r.d(t,{BufferObject:()=>i.g,FramebufferObject:()=>s.H,Program:()=>a.B,ProgramCache:()=>n.J,Renderbuffer:()=>o.l,ShaderCompiler:()=>c.Z,Texture:()=>l.g,VertexArrayObject:()=>h.Z,createContext:()=>d.q,createProgram:()=>u.r,glslifyDefineMap:()=>_.I});var i=r(70411),s=r(72848),a=r(68194),n=r(65544),o=r(68132),c=r(81642),l=r(34124),h=r(81652),_=r(13575),u=r(3966),d=r(87374)},67330:(e,t,r)=>{var i;r.d(t,{p:()=>i}),function(e){e[e.Texture=0]="Texture",e[e.RenderBuffer=1]="RenderBuffer"}(i||(i={}))},65544:(e,t,r)=>{r.d(t,{J:()=>a}),r(82555);var i=r(36852),s=r(68194);class a{constructor(e){this._rctx=e,this._store=new i.O}dispose(){this._store.forEach((e=>e.forEach((e=>e.dispose())))),this._store.clear()}acquire(e,t,r,i){const a=this._store.get(e,t);if(null!=a)return a.ref(),a;const n=new s.B(this._rctx,e,t,r,i);return n.ref(),this._store.set(e,t,n),n}get test(){}}},3966:(e,t,r)=>{r.d(t,{r:()=>s});var i=r(68194);function s(e,t,r=""){return new i.B(e,r+t.shaders.vertexShader,r+t.shaders.fragmentShader,t.attributes)}},81642:(e,t,r)=>{r.d(t,{Z:()=>i});class i{constructor(e){this._readFile=e}resolveIncludes(e){return this._resolve(e)}_resolve(e,t=new Map){if(t.has(e))return t.get(e);const r=this._read(e);if(!r)throw new Error(`cannot find shader file ${e}`);const i=/^[^\S\n]*#include\s+<(\S+)>[^\S\n]?/gm;let s=i.exec(r);const a=[];for(;null!=s;)a.push({path:s[1],start:s.index,length:s[0].length}),s=i.exec(r);let n=0,o="";return a.forEach((e=>{o+=r.slice(n,e.start),o+=t.has(e.path)?"":this._resolve(e.path,t),n=e.start+e.length})),o+=r.slice(n),t.set(e,o),o}_read(e){return this._readFile(e)}}},34124:(e,t,r)=>{r.d(t,{g:()=>l});var i=r(41509),s=(r(82555),r(4785)),a=r(85262),n=r(67330),o=r(98770);class c extends o.R{constructor(e,t){switch(super(),this.context=e,Object.assign(this,t),this.internalFormat){case a.H0.R16F:case a.H0.R16I:case a.H0.R16UI:case a.H0.R32F:case a.H0.R32I:case a.H0.R32UI:case a.H0.R8_SNORM:case a.H0.R8:case a.H0.R8I:case a.H0.R8UI:this.pixelFormat=a.Ab.RED}}static validate(e,t){return new c(e,t)}}let l=class e{constructor(e,t=null,r=null){if(this.type=n.p.Texture,this._glName=null,this._samplingModeDirty=!1,this._wrapModeDirty=!1,this._wasImmutablyAllocated=!1,"context"in e)this._descriptor=e,r=t;else{const r=c.validate(e,t);if(!r)throw new i.A("Texture descriptor invalid");this._descriptor=r}this._descriptor.target===a.Ap.TEXTURE_CUBE_MAP?this._setDataCubeMap(r):this.setData(r)}get glName(){return this._glName}get descriptor(){return this._descriptor}get usedMemory(){return(0,o.e)(this._descriptor)}get isDirty(){return this._samplingModeDirty||this._wrapModeDirty}dispose(){this._glName&&this._descriptor.context.instanceCounter.decrement(a.vt.Texture,this),this._descriptor.context.gl&&this._glName&&(this._descriptor.context.unbindTexture(this),this._descriptor.context.gl.deleteTexture(this._glName),this._glName=null)}release(){this.dispose()}resize(e,t){const r=this._descriptor;if(r.width!==e||r.height!==t){if(this._wasImmutablyAllocated)throw new i.A("Immutable textures can't be resized!");r.width=e,r.height=t,this._descriptor.target===a.Ap.TEXTURE_CUBE_MAP?this._setDataCubeMap(null):this.setData(null)}}_setDataCubeMap(e=null){for(let t=a.Ap.TEXTURE_CUBE_MAP_POSITIVE_X;t<=a.Ap.TEXTURE_CUBE_MAP_NEGATIVE_Z;t++)this._setData(e,t)}setData(e){this._setData(e)}_setData(t,r){if(!this._descriptor.context?.gl)return;const n=this._descriptor.context.gl;(0,s.Y2)(n),this._glName||(this._glName=n.createTexture(),this._glName&&this._descriptor.context.instanceCounter.increment(a.vt.Texture,this)),void 0===t&&(t=null);const o=this._descriptor,c=r??o.target,l=m(c);null===t&&(o.width=o.width||4,o.height=o.height||4,l&&(o.depth=o.depth??1));const A=this._descriptor.context.bindTexture(this,e.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(e.TEXTURE_UNIT_FOR_UPDATES),h(o),this._configurePixelStorage(),(0,s.Y2)(n);const f=this._deriveInternalFormat();if(p(t)){let e="width"in t?t.width:t.codedWidth,r="height"in t?t.height:t.codedHeight;const i=1;t instanceof HTMLVideoElement&&(e=t.videoWidth,r=t.videoHeight),o.width&&o.height,l&&o.depth,o.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(c,f,o.hasMipmap,e,r,i),this._texImage(c,0,f,e,r,i,t),(0,s.Y2)(n),o.hasMipmap&&this.generateMipmap(),o.width||(o.width=e),o.height||(o.height=r),l&&!o.depth&&(o.depth=i)}else{const{width:e,height:r,depth:h}=o;if(null==e||null==r)throw new i.A("Width and height must be specified!");if(l&&null==h)throw new i.A("Depth must be specified!");if(o.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(c,f,o.hasMipmap,e,r,h),d(t)){const s=t.levels,l=E(c,e,r,h),_=Math.min(l-1,s.length-1);n.texParameteri(o.target,this._descriptor.context.gl.TEXTURE_MAX_LEVEL,_);const u=f;if(!(u in a.CQ))throw new i.A("Attempting to use compressed data with an uncompressed format!");this._forEachMipmapLevel(((e,t,r,i)=>{const a=s[Math.min(e,s.length-1)];this._compressedTexImage(c,e,u,t,r,i,a)}),_)}else this._texImage(c,0,f,e,r,h,t),(0,s.Y2)(n),o.hasMipmap&&this.generateMipmap()}_(n,this._descriptor),u(n,this._descriptor),function(e,t){const r=e.capabilities.textureFilterAnisotropic;r&&e.gl.texParameterf(t.target,r.TEXTURE_MAX_ANISOTROPY,t.maxAnisotropy??1)}(this._descriptor.context,this._descriptor),(0,s.Y2)(n),this._descriptor.context.bindTexture(A,e.TEXTURE_UNIT_FOR_UPDATES)}updateData(t,r,s,a,n,o,c=0){o||console.error("An attempt to use uninitialized data!"),this._glName||console.error("An attempt to update uninitialized texture!");const l=this._descriptor,h=this._deriveInternalFormat(),{context:_,pixelFormat:u,dataType:m,target:E,isImmutable:A}=l;if(A&&!this._wasImmutablyAllocated)throw new i.A("Cannot update immutable texture before allocation!");const f=_.bindTexture(this,e.TEXTURE_UNIT_FOR_UPDATES,!0);(r<0||s<0||r+a>l.width||s+n>l.height)&&console.error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage();const{gl:g}=_;c&&g.pixelStorei(g.UNPACK_SKIP_ROWS,c),p(o)?g.texSubImage2D(E,t,r,s,a,n,u,m,o):d(o)?g.compressedTexSubImage2D(E,t,r,s,a,n,h,o.levels[t]):g.texSubImage2D(E,t,r,s,a,n,u,m,o),c&&g.pixelStorei(g.UNPACK_SKIP_ROWS,0),_.bindTexture(f,e.TEXTURE_UNIT_FOR_UPDATES)}updateData3D(t,r,s,a,n,o,c,l){l||console.error("An attempt to use uninitialized data!"),this._glName||console.error("An attempt to update uninitialized texture!");const h=this._descriptor,_=this._deriveInternalFormat(),{context:u,pixelFormat:p,dataType:E,isImmutable:A,target:f}=h;if(A&&!this._wasImmutablyAllocated)throw new i.A("Cannot update immutable texture before allocation!");m(f)||console.warn("Attempting to set 3D texture data on a non-3D texture");const g=u.bindTexture(this,e.TEXTURE_UNIT_FOR_UPDATES);u.setActiveTexture(e.TEXTURE_UNIT_FOR_UPDATES),(r<0||s<0||a<0||r+n>h.width||s+o>h.height||a+c>h.depth)&&console.error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage();const{gl:T}=u;if(d(l))l=l.levels[t],T.compressedTexSubImage3D(f,t,r,s,a,n,o,c,_,l);else{const e=l;T.texSubImage3D(f,t,r,s,a,n,o,c,p,E,e)}u.bindTexture(g,e.TEXTURE_UNIT_FOR_UPDATES)}generateMipmap(){const t=this._descriptor;if(!t.hasMipmap){if(this._wasImmutablyAllocated)throw new i.A("Cannot add mipmaps to immutable texture after allocation");t.hasMipmap=!0,this._samplingModeDirty=!0,h(t)}t.samplingMode===a.Cj.LINEAR?(this._samplingModeDirty=!0,t.samplingMode=a.Cj.LINEAR_MIPMAP_NEAREST):t.samplingMode===a.Cj.NEAREST&&(this._samplingModeDirty=!0,t.samplingMode=a.Cj.NEAREST_MIPMAP_NEAREST);const r=this._descriptor.context.bindTexture(this,e.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(e.TEXTURE_UNIT_FOR_UPDATES),this._descriptor.context.gl.generateMipmap(t.target),this._descriptor.context.bindTexture(r,e.TEXTURE_UNIT_FOR_UPDATES)}clearMipmap(){const e=this._descriptor;if(e.hasMipmap){if(this._wasImmutablyAllocated)throw new i.A("Cannot delete mipmaps to immutable texture after allocation");e.hasMipmap=!1,this._samplingModeDirty=!0,h(e)}e.samplingMode===a.Cj.LINEAR_MIPMAP_NEAREST?(this._samplingModeDirty=!0,e.samplingMode=a.Cj.LINEAR):e.samplingMode===a.Cj.NEAREST_MIPMAP_NEAREST&&(this._samplingModeDirty=!0,e.samplingMode=a.Cj.NEAREST)}setSamplingMode(e){e!==this._descriptor.samplingMode&&(this._descriptor.samplingMode=e,this._samplingModeDirty=!0)}setWrapMode(e){e!==this._descriptor.wrapMode&&(this._descriptor.wrapMode=e,h(this._descriptor),this._wrapModeDirty=!0)}applyChanges(){const e=this._descriptor,t=e.context.gl;this._samplingModeDirty&&(_(t,e),this._samplingModeDirty=!1),this._wrapModeDirty&&(u(t,e),this._wrapModeDirty=!1)}_deriveInternalFormat(){if(null!=this._descriptor.internalFormat)return this._descriptor.internalFormat===a.Ab.DEPTH_STENCIL&&(this._descriptor.internalFormat=a.Ab.DEPTH24_STENCIL8),this._descriptor.internalFormat;switch(this._descriptor.dataType){case a.ld.FLOAT:switch(this._descriptor.pixelFormat){case a.Ab.RGBA:return this._descriptor.internalFormat=a.H0.RGBA32F;case a.Ab.RGB:return this._descriptor.internalFormat=a.H0.RGB32F;default:throw new i.A("Unable to derive format")}case a.ld.UNSIGNED_BYTE:switch(this._descriptor.pixelFormat){case a.Ab.RGBA:return this._descriptor.internalFormat=a.H0.RGBA8;case a.Ab.RGB:return this._descriptor.internalFormat=a.H0.RGB8}}return this._descriptor.internalFormat=this._descriptor.pixelFormat===a.Ab.DEPTH_STENCIL?a.Ab.DEPTH24_STENCIL8:this._descriptor.pixelFormat}_configurePixelStorage(){const e=this._descriptor.context.gl,{unpackAlignment:t,flipped:r,preMultiplyAlpha:i}=this._descriptor;e.pixelStorei(e.UNPACK_ALIGNMENT,t),e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,r?1:0),e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,i?1:0)}_texStorage(e,t,r,s,n,o){const{gl:c}=this._descriptor.context;if(!(t in a.H0))throw new i.A("Immutable textures must have a sized internal format");if(!this._descriptor.isImmutable)return;const l=r?E(e,s,n,o):1;if(m(e)){if(null==o)throw new i.A("Missing depth dimension for 3D texture upload");c.texStorage3D(e,l,t,s,n,o)}else c.texStorage2D(e,l,t,s,n);this._wasImmutablyAllocated=!0}_texImage(e,t,r,s,a,n,o){const c=this._descriptor.context.gl,l=m(e),{isImmutable:h,pixelFormat:_,dataType:u}=this._descriptor;if(h){if(null!=o){const r=o;if(l){if(null==n)throw new i.A("Missing depth dimension for 3D texture upload");c.texSubImage3D(e,t,0,0,0,s,a,n,_,u,r)}else c.texSubImage2D(e,t,0,0,s,a,_,u,r)}}else{const h=o;if(l){if(null==n)throw new i.A("Missing depth dimension for 3D texture upload");c.texImage3D(e,t,r,s,a,n,0,_,u,h)}else c.texImage2D(e,t,r,s,a,0,_,u,h)}}_compressedTexImage(e,t,r,s,a,n,o){const c=this._descriptor.context.gl,l=m(e);if(this._descriptor.isImmutable){if(null!=o)if(l){if(null==n)throw new i.A("Missing depth dimension for 3D texture upload");c.compressedTexSubImage3D(e,t,0,0,0,s,a,n,r,o)}else c.compressedTexSubImage2D(e,t,0,0,s,a,r,o)}else if(l){if(null==n)throw new i.A("Missing depth dimension for 3D texture upload");c.compressedTexImage3D(e,t,r,s,a,n,0,o)}else c.compressedTexImage2D(e,t,r,s,a,0,o)}_forEachMipmapLevel(e,t=1/0){let{width:r,height:s,depth:n,hasMipmap:o,target:c}=this._descriptor;const l=c===a.Ap.TEXTURE_3D;if(null==r||null==s||l&&null==n)throw new i.A("Missing texture dimensions for mipmap calculation");for(let i=0;e(i,r,s,n),o&&(1!==r||1!==s||l&&1!==n)&&!(i>=t);++i)r=Math.max(1,r>>1),s=Math.max(1,s>>1),l&&(n=Math.max(1,n>>1))}};function h(e){(null!=e.width&&e.width<0||null!=e.height&&e.height<0||null!=e.depth&&e.depth<0)&&console.error("Negative dimension parameters are not allowed!")}function _(e,t){let r=t.samplingMode,i=t.samplingMode;r===a.Cj.LINEAR_MIPMAP_NEAREST||r===a.Cj.LINEAR_MIPMAP_LINEAR?(r=a.Cj.LINEAR,t.hasMipmap||(i=a.Cj.LINEAR)):r!==a.Cj.NEAREST_MIPMAP_NEAREST&&r!==a.Cj.NEAREST_MIPMAP_LINEAR||(r=a.Cj.NEAREST,t.hasMipmap||(i=a.Cj.NEAREST)),e.texParameteri(t.target,e.TEXTURE_MAG_FILTER,r),e.texParameteri(t.target,e.TEXTURE_MIN_FILTER,i)}function u(e,t){"number"==typeof t.wrapMode?(e.texParameteri(t.target,e.TEXTURE_WRAP_S,t.wrapMode),e.texParameteri(t.target,e.TEXTURE_WRAP_T,t.wrapMode)):(e.texParameteri(t.target,e.TEXTURE_WRAP_S,t.wrapMode.s),e.texParameteri(t.target,e.TEXTURE_WRAP_T,t.wrapMode.t))}function d(e){return null!=e&&"type"in e&&"compressed"===e.type}function p(e){return null!=e&&!d(e)&&!function(e){return null!=e&&"byteLength"in e}(e)}function m(e){return e===a.Ap.TEXTURE_3D||e===a.Ap.TEXTURE_2D_ARRAY}function E(e,t,r,i=1){let s=Math.max(t,r);return e===a.Ap.TEXTURE_3D&&(s=Math.max(s,i)),Math.round(Math.log(s)/Math.LN2)+1}l.TEXTURE_UNIT_FOR_UPDATES=0},98770:(e,t,r)=>{r.d(t,{R:()=>a,e:()=>n});var i=r(85262),s=r(69934);class a{constructor(e=0,t=e){this.width=e,this.height=t,this.target=i.Ap.TEXTURE_2D,this.pixelFormat=i.Ab.RGBA,this.dataType=i.ld.UNSIGNED_BYTE,this.samplingMode=i.Cj.LINEAR,this.wrapMode=i.pF.REPEAT,this.maxAnisotropy=1,this.flipped=!1,this.hasMipmap=!1,this.isOpaque=!1,this.unpackAlignment=4,this.preMultiplyAlpha=!1,this.depth=1,this.isImmutable=!1}}function n(e){return e.width<=0||e.height<=0?0:Math.round(e.width*e.height*(e.hasMipmap?4/3:1)*(null==e.internalFormat?4:(0,s.IB)(e.internalFormat)))}},69934:(e,t,r)=>{r.d(t,{IB:()=>c,WH:()=>n,yu:()=>o}),r(82555);var i=r(4785),s=r(85262),a=r(23457);function n(e){const t=e.gl;switch(t.getError()){case t.NO_ERROR:return null;case t.INVALID_ENUM:return"An unacceptable value has been specified for an enumerated argument";case t.INVALID_VALUE:return"An unacceptable value has been specified for an argument";case t.INVALID_OPERATION:return"The specified command is not allowed for the current state";case t.INVALID_FRAMEBUFFER_OPERATION:return"The currently bound framebuffer is not framebuffer complete";case t.OUT_OF_MEMORY:return"Not enough memory is left to execute the command";case t.CONTEXT_LOST_WEBGL:return"WebGL context is lost"}return"Unknown error"}function o(e,t,r,s,o=0){const c=e.gl;e.bindBuffer(r);for(const r of s){const s=t.get(r.name);if(void 0===s){console.warn(`There is no location for vertex attribute '${r.name}' defined.`);continue}const l=o*r.stride;if(r.count<=4)c.vertexAttribPointer(s,r.count,r.type,r.normalized,r.stride,r.offset+l),c.enableVertexAttribArray(s),r.divisor>0&&e.gl.vertexAttribDivisor(s,r.divisor);else if(9===r.count)for(let t=0;t<3;t++)c.vertexAttribPointer(s+t,3,r.type,r.normalized,r.stride,r.offset+12*t+l),c.enableVertexAttribArray(s+t),r.divisor>0&&e.gl.vertexAttribDivisor(s+t,r.divisor);else if(16===r.count)for(let t=0;t<4;t++)c.vertexAttribPointer(s+t,4,r.type,r.normalized,r.stride,r.offset+16*t+l),c.enableVertexAttribArray(s+t),r.divisor>0&&e.gl?.vertexAttribDivisor(s+t,r.divisor);else console.error("Unsupported vertex attribute element count: "+r.count);if((0,i.en)()){const t=n(e),i=(0,a._)(r.type),s=r.offset,o=Math.round(i/s)!==i/s?`. Offset not a multiple of stride. DataType requires ${i} bytes, but descriptor has an offset of ${s}`:"";t&&console.error(`Unable to bind vertex attribute "${r.name}" with baseInstanceOffset ${l}${o}:`,t,r)}}}function c(e){switch(e){case s.Ab.ALPHA:case s.Ab.LUMINANCE:case s.Ab.RED:case s.Ab.RED_INTEGER:case s.H0.R8:case s.H0.R8I:case s.H0.R8UI:case s.H0.R8_SNORM:case s.yQ.STENCIL_INDEX8:return 1;case s.Ab.LUMINANCE_ALPHA:case s.Ab.RG:case s.Ab.RG_INTEGER:case s.H0.RGBA4:case s.H0.R16F:case s.H0.R16I:case s.H0.R16UI:case s.H0.RG8:case s.H0.RG8I:case s.H0.RG8UI:case s.H0.RG8_SNORM:case s.H0.RGB565:case s.H0.RGB5_A1:case s.yQ.DEPTH_COMPONENT16:return 2;case s.Ab.DEPTH_COMPONENT:case s.Ab.RGB:case s.Ab.RGB_INTEGER:case s.H0.RGB8:case s.H0.RGB8I:case s.H0.RGB8UI:case s.H0.RGB8_SNORM:case s.H0.SRGB8:case s.yQ.DEPTH_COMPONENT24:return 3;case s.Ab.DEPTH_STENCIL:case s.Ab.DEPTH24_STENCIL8:case s.Ab.RGBA:case s.Ab.RGBA_INTEGER:case s.H0.RGBA8:case s.H0.R32F:case s.H0.R11F_G11F_B10F:case s.H0.RG16F:case s.H0.R32I:case s.H0.R32UI:case s.H0.RG16I:case s.H0.RG16UI:case s.H0.RGBA8I:case s.H0.RGBA8UI:case s.H0.RGBA8_SNORM:case s.H0.SRGB8_ALPHA8:case s.H0.RGB9_E5:case s.H0.RGB10_A2UI:case s.H0.RGB10_A2:case s.yQ.DEPTH_STENCIL:case s.yQ.DEPTH_COMPONENT32F:case s.yQ.DEPTH24_STENCIL8:return 4;case s.yQ.DEPTH32F_STENCIL8:return 5;case s.H0.RGB16F:case s.H0.RGB16I:case s.H0.RGB16UI:return 6;case s.H0.RG32F:case s.H0.RG32I:case s.H0.RG32UI:case s.H0.RGBA16F:case s.H0.RGBA16I:case s.H0.RGBA16UI:return 8;case s.H0.RGB32F:case s.H0.RGB32I:case s.H0.RGB32UI:return 12;case s.H0.RGBA32F:case s.H0.RGBA32I:case s.H0.RGBA32UI:return 16;case s.CQ.COMPRESSED_RGB_S3TC_DXT1_EXT:case s.CQ.COMPRESSED_RGBA_S3TC_DXT1_EXT:return.5;case s.CQ.COMPRESSED_RGBA_S3TC_DXT3_EXT:case s.CQ.COMPRESSED_RGBA_S3TC_DXT5_EXT:return 1;case s.CQ.COMPRESSED_R11_EAC:case s.CQ.COMPRESSED_SIGNED_R11_EAC:case s.CQ.COMPRESSED_RGB8_ETC2:case s.CQ.COMPRESSED_SRGB8_ETC2:case s.CQ.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case s.CQ.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:return.5;case s.CQ.COMPRESSED_RG11_EAC:case s.CQ.COMPRESSED_SIGNED_RG11_EAC:case s.CQ.COMPRESSED_RGBA8_ETC2_EAC:case s.CQ.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return 1}return 0}},81652:(e,t,r)=>{r.d(t,{Z:()=>l});var i=r(16431),s=r(18015),a=r(85258),n=r(85262),o=r(69934);const c=()=>i.A.getLogger("esri.views.webgl.VertexArrayObject");let l=class{constructor(e,t,r,i,s=null){this._context=e,this._locations=t,this._layout=r,this._buffers=i,this._indexBuffer=s,this._glName=null,this._initialized=!1}get glName(){return this._glName}get context(){return this._context}get vertexBuffers(){return this._buffers}get indexBuffer(){return this._indexBuffer}get byteSize(){return Object.keys(this._buffers).reduce(((e,t)=>e+this._buffers[t].usedMemory),null!=this._indexBuffer?this._indexBuffer.usedMemory:0)}get layout(){return this._layout}get locations(){return this._locations}get usedMemory(){return this.byteSize+(Object.keys(this._buffers).length+(this._indexBuffer?1:0))*a.zQ}dispose(){if(this._context){this._context.getBoundVAO()===this&&this._context.bindVAO(null);for(const e in this._buffers)this._buffers[e]?.dispose(),delete this._buffers[e];this._indexBuffer=(0,s.WD)(this._indexBuffer),this.disposeVAOOnly()}else(this._glName||Object.getOwnPropertyNames(this._buffers).length>0)&&c().warn("Leaked WebGL VAO")}disposeVAOOnly(){this._glName&&(this._context.gl.deleteVertexArray(this._glName),this._glName=null,this._context.instanceCounter.decrement(n.vt.VertexArrayObject,this)),this._context=null}initialize(){if(this._initialized)return;const{gl:e}=this._context,t=e.createVertexArray();e.bindVertexArray(t),this._bindLayout(),e.bindVertexArray(null),this._glName=t,this._context.instanceCounter.increment(n.vt.VertexArrayObject,this),this._initialized=!0}bind(){this.initialize(),this._context.gl.bindVertexArray(this.glName)}_bindLayout(){const{_buffers:e,_layout:t,_indexBuffer:r}=this;e||c().error("Vertex buffer dictionary is empty!");const i=this._context.gl;for(const r in e){const i=e[r];i||c().error("Vertex buffer is uninitialized!");const s=t[r];s||c().error("Vertex element descriptor is empty!"),(0,o.yu)(this._context,this._locations,i,s)}null!=r&&i.bindBuffer(i.ELEMENT_ARRAY_BUFFER,r.glName)}unbind(){this.initialize(),this._context.gl.bindVertexArray(null)}}},4785:(e,t,r)=>{r.d(t,{Xc:()=>l,Y2:()=>h,en:()=>c});var i=r(41509),s=r(82555),a=r(16431);const n=()=>a.A.getLogger("esri.views.webgl.checkWebGLError"),o=!!(0,s.A)("enable-feature:webgl-debug");function c(){return o}function l(){return o}function h(e){if(c()){const t=e.getError();if(t){const r=function(e,t){switch(t){case e.INVALID_ENUM:return"Invalid Enum. An unacceptable value has been specified for an enumerated argument.";case e.INVALID_VALUE:return"Invalid Value. A numeric argument is out of range.";case e.INVALID_OPERATION:return"Invalid Operation. The specified command is not allowed for the current state.";case e.INVALID_FRAMEBUFFER_OPERATION:return"Invalid Framebuffer operation. The currently bound framebuffer is not framebuffer complete when trying to render to or to read from it.";case e.OUT_OF_MEMORY:return"Out of memory. Not enough memory is left to execute the command.";case e.CONTEXT_LOST_WEBGL:return"WebGL context has been lost";default:return"Unknown error"}}(e,t),s=(new Error).stack;n().error(new i.A("webgl-error","WebGL error occurred",{message:r,stack:s}))}}}},23457:(e,t,r)=>{r.d(t,{_:()=>s});var i=r(85262);function s(e){switch(e){case i.pe.BYTE:case i.pe.UNSIGNED_BYTE:return 1;case i.pe.SHORT:case i.pe.UNSIGNED_SHORT:case i.pe.HALF_FLOAT:return 2;case i.pe.FLOAT:case i.pe.INT:case i.pe.UNSIGNED_INT:return 4}}},13575:(e,t,r)=>{function i(e){const{options:t,value:r}=e;return"number"==typeof t[r]}function s(e){let t="";for(const r in e){const s=e[r];if("boolean"==typeof s)s&&(t+=`#define ${r}\n`);else if("number"==typeof s)t+=`#define ${r} ${s.toFixed()}\n`;else if("object"==typeof s)if(i(s)){const{value:e,options:i,namespace:a}=s,n=a?`${a}_`:"";for(const e in i)t+=`#define ${n}${e} ${i[e].toFixed()}\n`;t+=`#define ${r} ${n}${e}\n`}else{const e=s.options;let i=0;for(const r in e)t+=`#define ${e[r]} ${(i++).toFixed()}\n`;t+=`#define ${r} ${e[s.value]}\n`}}return t}r.d(t,{I:()=>s})}}]);